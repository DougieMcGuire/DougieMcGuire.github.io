<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Instagram Data Viewer</title>
<style>
body { background:#0f0f0f; color:#fff; font-family:Inter,Arial,sans-serif; margin:0; padding:20px; }
h1, h2 { margin:10px 0; }
input { padding:10px; font-size:16px; }
section { margin-bottom:30px; }
.grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); gap:10px; }
.card { background:#181818; padding:10px; border-radius:10px; cursor:pointer; text-align:center; }
.card p { margin:5px 0; }
.card .timestamp { font-size:12px; color:#ccc; }
</style>
</head>
<body>
<h1>Instagram Data Viewer (ZIP)</h1>
<p>Select your Instagram ZIP file:</p>
<input type="file" id="zipInput" accept=".zip"/>
<div id="output"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
const zipInput=document.getElementById('zipInput');
const output=document.getElementById('output');

zipInput.addEventListener('change', async e=>{
    const file=e.target.files[0];
    if(!file) return;
    output.innerHTML='<p>Loading ZIP...</p>';
    
    const jszip=new JSZip();
    const zip=await jszip.loadAsync(file);
    const followers=[], unfollowers=[], contacts=[];

    for(const f of Object.values(zip.files)){
        if(f.name.includes('followers') && f.name.endsWith('.json')){
            const text=await f.async('text');
            const data=JSON.parse(text);
            data.forEach(entry=>{
                if(entry.string_list_data){
                    const u=entry.string_list_data[0];
                    if(u?.value) followers.push({username:u.value, href:u.href, timestamp:u.timestamp});
                }
            });
        } else if(f.name.includes('recently_unfollowed') && f.name.endsWith('.json')){
            const text=await f.async('text');
            const data=JSON.parse(text);
            data.forEach(entry=>{
                if(entry.string_list_data){
                    const u=entry.string_list_data[0];
                    if(u?.value) unfollowers.push({username:u.value, href:u.href, timestamp:u.timestamp});
                }
            });
        } else if(f.name.includes('synced_contacts') && f.name.endsWith('.json')){
            const text=await f.async('text');
            const data=JSON.parse(text);
            if(data.contacts_contact_info){
                data.contacts_contact_info.forEach(c=>{
                    const name=c.string_map_data?.['First Name']?.value||'';
                    const info=c.string_map_data?.['Contact Information']?.value||'';
                    contacts.push({name, info});
                });
            }
        }
    }

    output.innerHTML='';
    function makeSection(title, items, isUser=true){
        const sec=document.createElement('section');
        sec.innerHTML=`<h2>${title} (${items.length})</h2>`;
        if(!items.length){sec.innerHTML+='<p>None</p>'; return sec;}
        const grid=document.createElement('div');
        grid.className='grid';
        items.forEach(it=>{
            const card=document.createElement('div');
            card.className='card';
            if(isUser){
                card.innerHTML=`<p>@${it.username}</p>`+
                               `<p class="timestamp">${it.timestamp?new Date(it.timestamp*1000).toLocaleString():''}</p>`;
                card.onclick=()=>window.open(it.href,'_blank');
            } else {
                card.innerHTML=`<p>${it.name}</p><p class="timestamp">${it.info}</p>`;
            }
            grid.appendChild(card);
        });
        sec.appendChild(grid);
        return sec;
    }

    output.appendChild(makeSection('Followers', followers));
    output.appendChild(makeSection('Recently Unfollowed', unfollowers));
    output.appendChild(makeSection('Contacts', contacts, false));
});
</script>
</body>
</html>
